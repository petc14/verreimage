/**
 * =============================================
 * CONFIGURATEUR.MIN.JS - Verre & Image - 2025
 * - Logique pour le configurateur de plaque avancé
 * =============================================
 */
document.addEventListener('DOMContentLoaded', function() {
    // Vérification que les librairies THREE et fabric sont bien chargées
    if (typeof THREE === 'undefined' || typeof fabric === 'undefined') {
        console.error("Erreur: Les librairies Three.js ou Fabric.js ne sont pas chargées.");
        alert("Une erreur est survenue lors du chargement du configurateur. Veuillez réessayer plus tard.");
        return;
    }

    // --- State Management ---
    const state = {
        currentStep: 1,
        options: {
            taille: '30x22', // Default size
            fixation: 'plaque_seule', // Default fixation
            verification: true, // Default checked
            designer: false, // Default unchecked
            background_image: 'assets/images/Fleur/fle101.jpg', // Default background image path (relative to ASSETS_PATH/images)
        },
        prices: {
            taille: 175,
            fixation: 0,
            verification: 10,
            designer: 0,
        },
        // Store Fabric.js object properties for saving
        fabricObjectsData: [] // Will store JSON representation of all objects on canvas
    };

    // --- 3D Scene (Three.js) Variables ---
    let scene, camera, renderer, plaque, base;
    const initialPlaqueDimensions = { width: 3.0, height: 2.25, depth: 0.1 }; // For 30x22cm base proportion
    const initialBaseDimensions = { width: 3.5, height: 0.4, depth: 0.6 };

    // --- 2D Canvas for Personalization (Fabric.js) Variables ---
    let fabricCanvas, texture;
    const fabricCanvasDimensions = { width: 800, height: 600 }; // Resolution for the Fabric.js canvas

    // Function to get BASE_URL from the global context (defined in PHP header)
    function getBaseUrl() {
        return typeof BASE_URL !== 'undefined' ? BASE_URL : 'http://localhost/verre-image-site/public/';
    }
    const BASE_URL_JS = getBaseUrl();


    // --- 3D Scene Initialization ---
    function init3D() {
        const container = document.getElementById('canvas-container');
        if (!container) {
            console.error("Conteneur 3D non trouvé.");
            return;
        }

        // Scene setup
        scene = new THREE.Scene();
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(2, 5, 3);
        scene.add(directionalLight);

        // Camera setup
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 5.5);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        // Initialize 2D canvas for texture
        const fabricCanvasEl = document.getElementById('fabric-canvas');
        fabricCanvasEl.width = fabricCanvasDimensions.width;
        fabricCanvasEl.height = fabricCanvasDimensions.height;
        fabricCanvas = new fabric.Canvas('fabric-canvas', {
            selection: true, // Enable selection of objects
            preserveObjectStacking: true, // Keep object order during selection
            hoverCursor: 'pointer', // Change cursor on hover over objects
        });
        fabricCanvas.backgroundColor = '#FFFFFF'; // Ensure a white background for texture if no image is loaded
        fabricCanvas.renderAll();

        texture = new THREE.CanvasTexture(fabricCanvas.getElement());
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        // Plaque 3D setup
        const plaqueGeometry = new THREE.BoxGeometry(initialPlaqueDimensions.width, initialPlaqueDimensions.height, initialPlaqueDimensions.depth);
        const plaqueMaterial = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.1,
            metalness: 0.2,
            side: THREE.DoubleSide
        });
        plaque = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
        scene.add(plaque);

        // Base setup
        const baseGeometry = new THREE.BoxGeometry(initialBaseDimensions.width, initialBaseDimensions.height, initialBaseDimensions.depth);
        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
        base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = - (initialPlaqueDimensions.height / 2 + initialBaseDimensions.height / 2);
        scene.add(base);
        base.visible = (state.options.fixation !== 'plaque_seule');

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            texture.needsUpdate = true; // Crucial for updating the 3D model with 2D changes
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', onWindowResize, false);
        setup3DControls();

        // Fabric.js event listeners for updating UI based on selected object
        fabricCanvas.on('selection:cleared', updateToolbarForNoSelection);
        fabricCanvas.on('selection:created', updateToolbarForSelection);
        fabricCanvas.on('selection:updated', updateToolbarForSelection);
        fabricCanvas.on('object:modified', updateStateFabricObjects); // Object moved, scaled, rotated
        fabricCanvas.on('object:added', updateStateFabricObjects);
        fabricCanvas.on('object:removed', updateStateFabricObjects);
    }

    // --- 3D Controls ---
    function setup3DControls() {
        document.getElementById('zoom-in')?.addEventListener('click', () => { camera.position.z = Math.max(3, camera.position.z - 0.5); });
        document.getElementById('zoom-out')?.addEventListener('click', () => { camera.position.z = Math.min(10, camera.position.z + 0.5); });
        document.getElementById('rotate-left')?.addEventListener('click', () => {
            plaque.rotation.y -= Math.PI / 16;
            base.rotation.y -= Math.PI / 16;
        });
        document.getElementById('rotate-right')?.addEventListener('click', () => {
            plaque.rotation.y += Math.PI / 16;
            base.rotation.y += Math.PI / 16;
        });
    }

    function onWindowResize() {
        const container = document.getElementById('canvas-container');
        if (container && renderer) {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
    }

    // --- 2D Canvas Functions ---
    function updateFabricBackground(imageURL) {
        fabric.Image.fromURL(imageURL, (img) => {
            const scale = Math.max(fabricCanvas.width / img.width, fabricCanvas.height / img.height);
            img.set({
                scaleX: scale,
                scaleY: scale,
                originX: 'center',
                originY: 'center',
                top: fabricCanvas.height / 2,
                left: fabricCanvas.width / 2,
                selectable: false, // Background is not selectable
                evented: false // Background does not react to events
            });
            fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));
            state.options.background_image = imageURL.replace(BASE_URL_JS, ''); // Store relative path
            updateStateFabricObjects();
        }, { crossOrigin: 'anonymous' }); // Important for loading images from different origins
    }

    function addTextToCanvas(text) {
        let textObj = fabricCanvas.getObjects().find(obj => obj.type === 'i-text' && obj.text === textInput1.value); // Find existing object linked to textarea
        if (!textObj) {
            // If no active text object matches, or no text object exists, create a new one
            textObj = new fabric.IText(text, {
                left: fabricCanvas.width / 2,
                top: fabricCanvas.height / 2,
                fontFamily: 'Montserrat',
                fontSize: 40,
                fill: '#000000',
                originX: 'center',
                originY: 'center',
                shadow: 'rgba(0,0,0,0.3) 2px 2px 2px',
                selectable: true,
                hasControls: true // Display controls for resizing, rotating
            });
            fabricCanvas.add(textObj);
        } else {
            textObj.set('text', text);
        }
        fabricCanvas.renderAll();
        fabricCanvas.setActiveObject(textObj); // Make sure it's active so toolbar updates
        updateToolbarForSelection(); // Update toolbar for newly active text object
        updateStateFabricObjects();
    }

    function addImageToCanvas(src) {
        fabric.Image.fromURL(src, (img) => {
            if (img.width > fabricCanvas.width || img.height > fabricCanvas.height) {
                img.scaleToWidth(fabricCanvas.width * 0.5);
            }
            img.set({
                left: fabricCanvas.width / 2,
                top: fabricCanvas.height / 2,
                originX: 'center',
                originY: 'center',
                selectable: true,
                hasControls: true
            });
            fabricCanvas.add(img);
            fabricCanvas.setActiveObject(img);
            updateToolbarForSelection(); // Update toolbar for newly active image object
            updateStateFabricObjects();
        }, { crossOrigin: 'anonymous' });
    }

    // Function to update state with current Fabric.js objects (for saving to DB)
    function updateStateFabricObjects() {
        state.fabricObjectsData = fabricCanvas.getObjects().map(obj => obj.toObject([
            'left', 'top', 'scaleX', 'scaleY', 'angle', 'opacity', 'flipX', 'flipY', // Common properties
            'fill', 'fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'textDecoration', 'textAlign', 'lineHeight', // Text properties
            'src' // Image source (for uploaded images)
        ]));
    }


    // --- UI Update & Logic ---
    function updateUI() {
        document.querySelectorAll('.step').forEach(step => step.classList.toggle('active', parseInt(step.dataset.step) === state.currentStep));
        document.querySelectorAll('.panel-step').forEach(panel => panel.classList.toggle('active', parseInt(panel.id.split('-')[2]) === state.currentStep));

        document.getElementById('btn-back').disabled = (state.currentStep === 1);
        document.getElementById('btn-continue').textContent = (state.currentStep === 4) ? 'Ajouter au panier' : 'Continuer';

        // Show/hide toolbars based on current step
        if (state.currentStep === 3) {
            document.querySelector('.text-editor-toolbar').style.display = 'flex';
            document.querySelector('.object-controls-toolbar').style.display = 'flex';
            updateToolbarForSelection(); // Ensure toolbar state is correct when entering step 3
        } else {
            document.querySelector('.text-editor-toolbar').style.display = 'none';
            document.querySelector('.object-controls-toolbar').style.display = 'none';
        }

        // Update 3D model geometry based on selected size
        if (plaque) {
            let newWidth, newHeight;
            switch (state.options.taille) {
                case '24x18': newWidth = initialPlaqueDimensions.width * (24 / 30); newHeight = initialPlaqueDimensions.height * (18 / 22); break;
                case '30x22': newWidth = initialPlaqueDimensions.width; newHeight = initialPlaqueDimensions.height; break;
                case '40x30': newWidth = initialPlaqueDimensions.width * (40 / 30); newHeight = initialPlaqueDimensions.height * (30 / 22); break;
                default: newWidth = initialPlaqueDimensions.width; newHeight = initialPlaqueDimensions.height; break;
            }

            plaque.geometry.dispose();
            plaque.geometry = new THREE.BoxGeometry(newWidth, newHeight, initialPlaqueDimensions.depth);

            if (base) {
                base.position.y = - (newHeight / 2 + initialBaseDimensions.height / 2);
                base.visible = (state.options.fixation !== 'plaque_seule');
            }
        }
        calculateTotalPrice();
    }

    function calculateTotalPrice() {
        let total = Object.values(state.prices).reduce((sum, price) => sum + price, 0);
        document.getElementById('total-price').textContent = `${total.toFixed(2).replace('.', ',')}€`;
    }

    function getThumbnailForCart() {
        // Render current fabric canvas to a data URL
        const dataURL = fabricCanvas.toDataURL({
            format: 'jpeg',
            quality: 0.7,
            width: 300, // Desired thumbnail width
            height: 225 // Desired thumbnail height (maintaining aspect ratio if possible for 30x22)
        });
        // In a real application, you would send this Data URL to the server
        // to save it as a file (e.g., in public/assets/images/temp_thumbnails/)
        // and then return the server path.
        // For this simulation, we'll just use the placeholder.
        return 'assets/images/placeholder-plaque.jpg';
    }


    // --- Toolbar Management for Fabric.js Objects ---
    const textInput1 = document.getElementById('text-input-1');
    const fontFamilySelect = document.getElementById('font-family-select');
    const fontSizeInput = document.getElementById('font-size-input');
    const fontColorInput = document.getElementById('font-color-input');
    const textBoldBtn = document.getElementById('text-bold-btn');
    const textItalicBtn = document.getElementById('text-italic-btn');
    const textUnderlineBtn = document.getElementById('text-underline-btn');
    const textAlignLeftBtn = document.getElementById('text-align-left-btn');
    const textAlignCenterBtn = document.getElementById('text-align-center-btn');
    const textAlignRightBtn = document.getElementById('text-align-right-btn');
    const deleteObjectBtn = document.getElementById('delete-object-btn');
    const bringForwardBtn = document.getElementById('bring-forward-btn');
    const sendBackwardBtn = document.getElementById('send-backward-btn');
    const duplicateObjectBtn = document.getElementById('duplicate-object-btn');

    const textEditorToolbar = document.querySelector('.text-editor-toolbar');
    const objectControlsToolbar = document.querySelector('.object-controls-toolbar');

    function updateToolbarForNoSelection() {
        textInput1.value = '';
        fontFamilySelect.value = 'Montserrat';
        fontSizeInput.value = 40;
        fontColorInput.value = '#000000';
        textBoldBtn.classList.remove('active');
        textItalicBtn.classList.remove('active');
        textUnderlineBtn.classList.remove('active');
        textAlignLeftBtn.classList.remove('active');
        textAlignCenterBtn.classList.remove('active');
        textAlignRightBtn.classList.remove('active');

        textInput1.disabled = true;
        fontFamilySelect.disabled = true;
        fontSizeInput.disabled = true;
        fontColorInput.disabled = true;
        textBoldBtn.disabled = true;
        textItalicBtn.disabled = true;
        textUnderlineBtn.disabled = true;
        textAlignLeftBtn.disabled = true;
        textAlignCenterBtn.disabled = true;
        textAlignRightBtn.disabled = true;
        deleteObjectBtn.disabled = true;
        bringForwardBtn.disabled = true;
        sendBackwardBtn.disabled = true;
        duplicateObjectBtn.disabled = true;
    }

    function updateToolbarForSelection() {
        const activeObject = fabricCanvas.getActiveObject();

        // Re-enable all controls first
        textInput1.disabled = false;
        fontFamilySelect.disabled = false;
        fontSizeInput.disabled = false;
        fontColorInput.disabled = false;
        textBoldBtn.disabled = false;
        textItalicBtn.disabled = false;
        textUnderlineBtn.disabled = false;
        textAlignLeftBtn.disabled = false;
        textAlignCenterBtn.disabled = false;
        textAlignRightBtn.disabled = false;
        deleteObjectBtn.disabled = false;
        bringForwardBtn.disabled = false;
        sendBackwardBtn.disabled = false;
        duplicateObjectBtn.disabled = false;

        if (!activeObject) {
            updateToolbarForNoSelection();
            return;
        }

        if (activeObject.type === 'i-text') {
            textInput1.value = activeObject.text;
            fontFamilySelect.value = activeObject.fontFamily;
            fontSizeInput.value = activeObject.fontSize;
            fontColorInput.value = activeObject.fill;

            textBoldBtn.classList.toggle('active', activeObject.fontWeight === 'bold');
            textItalicBtn.classList.toggle('active', activeObject.fontStyle === 'italic');
            textUnderlineBtn.classList.toggle('active', activeObject.textDecoration.includes('underline')); // Use includes for potential multiple decorations

            textAlignLeftBtn.classList.toggle('active', activeObject.textAlign === 'left');
            textAlignCenterBtn.classList.toggle('active', activeObject.textAlign === 'center');
            textAlignRightBtn.classList.toggle('active', activeObject.textAlign === 'right');

        } else if (activeObject.type === 'image') {
            textInput1.value = ''; // Clear text area for image selection
            textInput1.disabled = true; // Disable text controls for image
            fontFamilySelect.disabled = true;
            fontSizeInput.disabled = true;
            fontColorInput.disabled = true;
            textBoldBtn.disabled = true;
            textItalicBtn.disabled = true;
            textUnderlineBtn.disabled = true;
            textAlignLeftBtn.disabled = true;
            textAlignCenterBtn.disabled = true;
            textAlignRightBtn.disabled = true;

            // Remove active states from text formatting buttons
            textBoldBtn.classList.remove('active');
            textItalicBtn.classList.remove('active');
            textUnderlineBtn.classList.remove('active');
            textAlignLeftBtn.classList.remove('active');
            textAlignCenterBtn.classList.remove('active');
            textAlignRightBtn.classList.remove('active');

        } else {
            updateToolbarForNoSelection();
        }
    }

    // --- Event Listeners ---
    function setupEventListeners() {
        // Step navigation
        document.getElementById('btn-continue').addEventListener('click', () => {
            if (state.currentStep < 4) {
                state.currentStep++;
                updateUI();
            } else {
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = BASE_URL_JS + 'panier/add';

                // Include Fabric.js objects data
                const fabricObjectsDataInput = document.createElement('input');
                fabricObjectsDataInput.type = 'hidden';
                fabricObjectsDataInput.name = 'fabric_objects_data';
                fabricObjectsDataInput.value = JSON.stringify(state.fabricObjectsData);
                form.appendChild(fabricObjectsDataInput);

                // Include other state options
                for (const key in state.options) {
                    if (state.options.hasOwnProperty(key)) {
                        const input = document.createElement('input');
                        input.type = 'hidden';
                        input.name = key;
                        if (key === 'image_uploads' || key === 'text_content') { // These are implicitly part of fabricObjectsData
                             continue;
                        }
                        if (typeof state.options[key] === 'object' && state.options[key] !== null) {
                            input.value = JSON.stringify(state.options[key]);
                        } else {
                            input.value = state.options[key];
                        }
                        form.appendChild(input);
                    }
                }

                const priceInput = document.createElement('input');
                priceInput.type = 'hidden';
                priceInput.name = 'price';
                priceInput.value = state.prices.taille + state.prices.fixation + state.prices.verification + state.prices.designer;
                form.appendChild(priceInput);

                const thumbnailInput = document.createElement('input');
                thumbnailInput.type = 'hidden';
                thumbnailInput.name = 'thumbnail_path';
                thumbnailInput.value = getThumbnailForCart();
                form.appendChild(thumbnailInput);

                document.body.appendChild(form);
                form.submit();
            }
        });

        document.getElementById('btn-back').addEventListener('click', () => {
            if (state.currentStep > 1) {
                state.currentStep--;
                updateUI();
            }
        });

        document.querySelectorAll('.step').forEach(step => {
           step.addEventListener('click', function() {
               const targetStep = parseInt(this.dataset.step);
               if (targetStep <= state.currentStep + 1 || targetStep <= 4) {
                   state.currentStep = targetStep;
                   updateUI();
               }
           });
        });

        // Option selection (size and fixation)
        document.querySelectorAll('.option-group[data-group]').forEach(group => {
            group.querySelectorAll('.option-box').forEach(box => {
                box.addEventListener('click', function() {
                    const groupName = group.dataset.group;
                    group.querySelectorAll('.option-box').forEach(otherBox => otherBox.classList.remove('selected'));
                    this.classList.add('selected');
                    state.options[groupName] = this.dataset.value;
                    state.prices[groupName] = parseFloat(this.dataset.price);
                    updateUI();
                });
            });
        });

        // Background selection
        document.querySelectorAll('#fonds-container .option-box').forEach(box => {
            box.addEventListener('click', function() {
                updateFabricBackground(this.dataset.imgSrc);
            });
        });

        // --- Text Editor Functionality ---
        textInput1.addEventListener('input', (e) => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('text', e.target.value);
            } else if (e.target.value.trim() !== '') { // Create new text object only if textarea is not empty
                addTextToCanvas(e.target.value);
            } else if (activeObject && activeObject.type === 'i-text' && e.target.value.trim() === '') {
                fabricCanvas.remove(activeObject); // Remove text object if textarea is cleared
                fabricCanvas.discardActiveObject();
                updateToolbarForNoSelection();
            }
            fabricCanvas.renderAll();
            updateStateFabricObjects();
        });

        fontFamilySelect.addEventListener('change', (e) => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('fontFamily', e.target.value);
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        fontSizeInput.addEventListener('input', (e) => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('fontSize', parseInt(e.target.value));
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        fontColorInput.addEventListener('input', (e) => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('fill', e.target.value);
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        textBoldBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('fontWeight', activeObject.fontWeight === 'bold' ? 'normal' : 'bold');
                textBoldBtn.classList.toggle('active', activeObject.fontWeight === 'bold');
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        textItalicBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('fontStyle', activeObject.fontStyle === 'italic' ? 'normal' : 'italic');
                textItalicBtn.classList.toggle('active', activeObject.fontStyle === 'italic');
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        textUnderlineBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                const currentDecoration = activeObject.textDecoration;
                if (currentDecoration && currentDecoration.includes('underline')) {
                    activeObject.set('textDecoration', currentDecoration.replace('underline', '').trim());
                } else {
                    activeObject.set('textDecoration', (currentDecoration ? currentDecoration + ' ' : '') + 'underline');
                }
                textUnderlineBtn.classList.toggle('active', activeObject.textDecoration.includes('underline'));
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        textAlignLeftBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('textAlign', 'left');
                updateToolbarForSelection(); // Update button states
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        textAlignCenterBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('textAlign', 'center');
                updateToolbarForSelection();
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        textAlignRightBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject && activeObject.type === 'i-text') {
                activeObject.set('textAlign', 'right');
                updateToolbarForSelection();
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        // --- Object Control Functionality ---
        deleteObjectBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject) {
                fabricCanvas.remove(activeObject);
                fabricCanvas.discardActiveObject(); // Deselect after deletion
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        bringForwardBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject) {
                fabricCanvas.bringForward(activeObject);
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        sendBackwardBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject) {
                fabricCanvas.sendBackwards(activeObject);
                fabricCanvas.renderAll();
                updateStateFabricObjects();
            }
        });

        duplicateObjectBtn.addEventListener('click', () => {
            const activeObject = fabricCanvas.getActiveObject();
            if (activeObject) {
                activeObject.clone(function(clonedObj) {
                    fabricCanvas.discardActiveObject();
                    clonedObj.set({
                        left: clonedObj.left + 10,
                        top: clonedObj.top + 10,
                        evented: true,
                        selectable: true,
                        hasControls: true
                    });
                    if (clonedObj.type === 'activeSelection') { // in case of group
                        clonedObj.canvas = fabricCanvas;
                        clonedObj.forEachObject(function(obj) {
                            fabricCanvas.add(obj);
                        });
                        clonedObj.setCoords();
                    } else {
                        fabricCanvas.add(clonedObj);
                    }
                    fabricCanvas.setActiveObject(clonedObj);
                    fabricCanvas.renderAll();
                    updateStateFabricObjects();
                });
            }
        });


        // Options Step 4 (checkboxes: verification, designer)
        document.querySelectorAll('.checkbox-option').forEach(option => {
            option.addEventListener('click', function(e){
                const checkbox = this.querySelector('input[type="checkbox"]');
                const groupName = this.dataset.group;
                if(e.target !== checkbox) checkbox.checked = !checkbox.checked;

                this.classList.toggle('selected', checkbox.checked);
                state.options[groupName] = checkbox.checked;
                state.prices[groupName] = checkbox.checked ? parseFloat(checkbox.dataset.price) : 0;

                if (groupName === 'designer') {
                    document.getElementById('designer-comment').style.display = checkbox.checked ? 'block' : 'none';
                }
                calculateTotalPrice();
            });
        });

        // Handle initial theme from URL (e.g., from Boutique page)
        const urlParams = new URLSearchParams(window.location.search);
        const themeToOpen = urlParams.get('theme');
        if (themeToOpen) {
            const themeGroupTitle = document.querySelector(`#fonds-container .option-group-title[title="${themeToOpen}"]`);
            if (themeGroupTitle) {
                const firstImageOption = themeGroupTitle.parentElement.querySelector('.option-grid .option-box');
                if (firstImageOption) {
                    firstImageOption.click();
                    state.currentStep = 2; // Automatically move to step 2 after setting background
                    updateUI(); // Update UI to reflect step change
                }
            }
        }
    }


    // --- Initialisation ---
    init3D();
    setupEventListeners();
    updateUI(); // Initial UI update to set correct state and price
    updateFabricBackground(BASE_URL_JS + state.options.background_image); // Set initial default background
});